// Copyright 2022 CYBERCRYPT
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by copy-client.sh. DO NOT EDIT.
// version: v0.1.47-ci.180
// source: https://github.com/cybercryptio/d1-service-generic.git
// commit: 181d63285cd0a8ae6fa257615c0a1c5a60529e25

package client

import (
	"context"
	"time"

	pbauthn "github.com/cybercryptio/d1-client-go/d1-generic/protobuf/authn"
	pbauthz "github.com/cybercryptio/d1-client-go/d1-generic/protobuf/authz"
	pbversion "github.com/cybercryptio/d1-client-go/d1-generic/protobuf/version"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/health/grpc_health_v1"
)

// BaseClient represents the shared functionality between various D1 services.
type BaseClient struct {
	Version    pbversion.VersionClient
	Authn      pbauthn.AuthnClient
	Authz      pbauthz.AuthzClient
	Health     grpc_health_v1.HealthClient
	Connection *grpc.ClientConn
}

// NewBaseClient creates a new client for the given endpoint. If certPath is not empty, TLS will be
// enabled using the given certificate file.
func NewBaseClient(endpoint, certPath string) (BaseClient, error) {
	var dialOption grpc.DialOption

	if certPath != "" {
		// Configure certificate
		clientCredentials, err := credentials.NewClientTLSFromFile(certPath, "")
		if err != nil {
			return BaseClient{}, err
		}
		dialOption = grpc.WithTransportCredentials(clientCredentials)
	} else {
		dialOption = grpc.WithTransportCredentials(insecure.NewCredentials())
	}

	// Initialize connection with the service
	conn, err := grpc.Dial(endpoint, dialOption)
	if err != nil {
		return BaseClient{}, err
	}

	return BaseClient{
		Version:    pbversion.NewVersionClient(conn),
		Authn:      pbauthn.NewAuthnClient(conn),
		Authz:      pbauthz.NewAuthzClient(conn),
		Health:     grpc_health_v1.NewHealthClient(conn),
		Connection: conn,
	}, nil
}

// Close closes all connections to the server.
func (b *BaseClient) Close() error {
	return b.Connection.Close()
}

// tokenRefresher handles automatic refreshing of the access token upon expiry by implementing
// credentials.PerRPCCredentials.
type tokenRefresher struct {
	endpoint   string
	certPath   string
	uid        string
	password   string
	token      string
	expiration time.Time
}

func (t *tokenRefresher) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
	// To avoid clock drift issues, refresh the token if it will expire within 1 minute.
	if time.Now().After(t.expiration.Add(time.Duration(-1) * time.Minute)) {
		c, err := NewBaseClient(t.endpoint, t.certPath)
		if err != nil {
			return nil, err
		}
		defer c.Close()

		res, err := c.Authn.LoginUser(
			ctx,
			&pbauthn.LoginUserRequest{
				UserId:   t.uid,
				Password: t.password,
			},
		)
		if err != nil {
			return nil, err
		}

		t.expiration = time.Unix(res.ExpiryTime, 0)
		t.token = res.AccessToken
	}

	return map[string]string{
		"authorization": "bearer " + t.token,
	}, nil
}

func (t *tokenRefresher) RequireTransportSecurity() bool {
	return false
}

// NewBaseClientWR creates a baseClient that automatically logs in and refreshes the access token
// using the provided credentials.
func NewBaseClientWR(endpoint, certPath, uid, password string) (BaseClient, error) {
	var dialOption grpc.DialOption

	if certPath != "" {
		// Configure certificate
		clientCredentials, err := credentials.NewClientTLSFromFile(certPath, "")
		if err != nil {
			return BaseClient{}, err
		}
		dialOption = grpc.WithTransportCredentials(clientCredentials)
	} else {
		dialOption = grpc.WithTransportCredentials(insecure.NewCredentials())
	}

	refresher := tokenRefresher{
		endpoint: endpoint,
		certPath: certPath,
		uid:      uid,
		password: password,
	}

	// Initialize connection with the service using the automatic token refresher.
	conn, err := grpc.Dial(endpoint, dialOption, grpc.WithPerRPCCredentials(&refresher))
	if err != nil {
		return BaseClient{}, err
	}

	return BaseClient{
		Version:    pbversion.NewVersionClient(conn),
		Authn:      pbauthn.NewAuthnClient(conn),
		Authz:      pbauthz.NewAuthzClient(conn),
		Health:     grpc_health_v1.NewHealthClient(conn),
		Connection: conn,
	}, nil
}
